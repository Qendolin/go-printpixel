package main

import "math"

func Earcut(data []float32, hole_indices []int, rdim int) []int {
	var dim int
	if rdim > 0 {
		dim = rdim
	} else {
		dim = 2
	}
	has_holes := len(hole_indices) > 0
	var outer_len int
	if has_holes {
		outer_len = hole_indices[0] * dim
	} else {
		outer_len = len(data)
	}
	outer_node := linked_list(data, 0, outer_len, dim, true)
	triangles := []int{}
	if (outer_node == nil) || outer_node.next == outer_node.prev {
		return triangles
	}
	min_x := float32(0)
	min_y := float32(0)
	max_x := float32(0)
	max_y := float32(0)
	x := float32(0)
	y := float32(0)
	inv_size := float32(0)
	if has_holes {
		outer_node = eliminate_holes(data, hole_indices, outer_node, dim)
	}
	// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	if len(data) > 80*dim {
		min_x = data[0]
		max_x = data[0]
		min_y = data[1]
		max_y = data[1]
		for i := dim; i < outer_len; i += dim {
			x = data[i]
			y = data[i+1]
			if x < min_x {
				min_x = x
			}
			if y < min_y {
				min_y = y
			}
			if x > max_x {
				max_x = x
			}
			if y > max_y {
				max_y = y
			}
		}
		// min_x, min_y and inv_size are later used to transform coords into integers for z-order calculation
		inv_size = max_float32(max_x-min_x, max_y-min_y)

		if inv_size != 0.0 {
			inv_size = 1 / inv_size
		} else {
			inv_size = 0
		}
	}
	earcut_linked(outer_node, triangles, dim, min_x, min_y, inv_size, 0)
	return triangles
}

// linked_list create a circular doubly linked list from polygon points in the specified winding order
func linked_list(data []float32, start int, end int, dim int, clockwise bool) *Node {
	i := 0
	last := &Node{}

	if clockwise == (signed_area(data, start, end, dim) > 0) {
		for i = start; i < end; i += dim {
			last = insert_node(i, data[i], data[i+1], last)
		}
	} else {
		for i = end - dim; i >= start; i -= dim {
			last = insert_node(i, data[i], data[i+1], last)
		}
	}

	if !(last == nil) && equals(last, last.next) {
		remove_node(last)
		last = last.next
	}
	return last
}

// filter_points eliminate colinear or duplicate points
func filter_points(start *Node, end *Node) *Node {
	if start == nil {
		return start
	}
	if end == nil {
		end = start
	}

	p := start
	again := false
	for {
		again = false
		if !p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) == 0) {
			remove_node(p)
			p = p.prev
			end = p.prev
			if p == p.next {
				break
			}
			again = true
		} else {
			p = p.next
		}
		if !(again || p != end) {
			break
		} //  while (again || p !== end);??
	}

	return end
}

// earcut_linked main ear slicing loop which triangulates a polygon (given as a linked list)
func earcut_linked(ear *Node, triangles []int, dim int, min_x float32, min_y float32, inv_size float32, pass int) {
	if ear == nil {
		return
	}
	// interlink polygon nodes in z-order
	if pass == 0 && inv_size > 0.0 {
		index_curve(ear, min_x, min_y, inv_size)
	}
	stop := ear
	prev := &Node{}
	next := &Node{}
	// iterate through ears, slicing them one by one
	for ear.prev != ear.next {
		prev = ear.prev
		next = ear.next
		var cutoff bool
		if inv_size > 0 {
			cutoff = is_ear_hashed(ear, min_x, min_y, inv_size)
		} else {
			cutoff = is_ear(ear)
		}
		if cutoff {
			// cut off the triangle
			triangles = append(triangles, prev.i/dim)
			triangles = append(triangles, ear.i/dim)
			triangles = append(triangles, next.i/dim)
			remove_node(ear)
			// skipping the next vertex leads to less sliver triangles
			ear = next.next
			stop = next.next
			continue
		}
		ear = next
		// if we looped through the whole remaining polygon and can't find any more ears
		if ear == stop {
			// try filtering points and slicing again
			if pass == 0 {
				res := filter_points(ear, nil)
				earcut_linked(res, triangles, dim, min_x, min_y, inv_size, 1)
				// if this didn't work, try curing all small self-intersections locally
			} else if pass == 1 {
				filtered := filter_points(ear, nil)
				ear = cure_local_intersections(filtered, triangles, dim)
				earcut_linked(ear, triangles, dim, min_x, min_y, inv_size, 2)
				// as a last resort, try splitting the remaining polygon into two
			} else if pass == 2 {
				split_earcut(ear, triangles, dim, min_x, min_y, inv_size)
			}
			break
		}
	}
}

// is_ear check whether a polygon node forms a valid ear with adjacent nodes
func is_ear(ear *Node) bool {
	a := ear.prev
	b := ear
	c := ear.next
	if area(a, b, c) >= 0 {
		return false
	} // reflex, can't be an ear
	// now make sure we don't have other points inside the potential ear
	p := ear.next.next
	for p != ear.prev {
		if point_in_triangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0 {
			return false
		}
		p = p.next
	}
	return true
}

func is_ear_hashed(ear *Node, min_x float32, min_y float32, inv_size float32) bool {
	a := ear.prev
	b := ear
	c := ear.next
	if area(a, b, c) >= 0 {
		return false
	} // reflex, can't be an ear
	// triangle bbox; min & max are calculated like this for speed
	var min_tx float32
	if a.x < b.x {
		if a.x < c.x {
			min_tx = a.x
		} else {
			min_tx = c.x
		}
	} else {
		if b.x < c.x {
			min_tx = b.x
		} else {
			min_tx = c.x
		}
	}
	var min_ty float32
	if a.y < b.y {
		if a.y < c.y {
			min_ty = a.y
		} else {
			min_ty = c.y
		}
	} else {
		if b.y < c.y {
			min_ty = b.y
		} else {
			min_ty = c.y
		}
	}
	var max_tx float32
	if a.x > b.x {
		if a.x > c.x {
			max_tx = a.x
		} else {
			max_tx = c.x
		}
	} else {
		if b.x > c.x {
			max_tx = b.x
		} else {
			max_tx = c.x
		}
	}
	var max_ty float32
	if a.y > b.y {
		if a.y > c.y {
			max_ty = a.y
		} else {
			max_ty = c.y
		}
	} else {
		if b.y > c.y {
			max_ty = b.y
		} else {
			max_ty = c.y
		}
	}
	// z-order range for the current triangle bbox;
	min_z := z_order(min_tx, min_ty, min_x, min_y, inv_size)
	max_z := z_order(max_tx, max_ty, min_x, min_y, inv_size)
	p := ear.prev_z
	n := ear.next_z
	// look for points inside the triangle in both directions
	for !(p == nil) && p.z >= min_z && !(n == nil) && n.z <= max_z {
		if p != ear.prev && p != ear.next &&
			point_in_triangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
			area(p.prev, p, p.next) >= 0 {
			return false
		}
		p = p.prev_z
		if n != ear.prev && n != ear.next &&
			point_in_triangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
			area(n.prev, n, n.next) >= 0 {
			return false
		}
		n = n.next_z
	}
	// look for remaining points in decreasing z-order
	for !(p == nil) && p.z >= min_z {
		if p != ear.prev && p != ear.next &&
			point_in_triangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
			area(p.prev, p, p.next) >= 0 {
			return false
		}
		p = p.prev_z
	}
	// look for remaining points in increasing z-order
	for !(n == nil) && n.z <= max_z {
		if n != ear.prev && n != ear.next &&
			point_in_triangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
			area(n.prev, n, n.next) >= 0 {
			return false
		}
		n = n.next_z
	}
	return true
}

// cure_local_intersections go through all polygon nodes and cure small local self-intersections
func cure_local_intersections(start *Node, triangles []int, dim int) *Node {
	p := start
	nil := &Node{}
	for {
		a := p.prev
		b := p.next.next
		if !equals(a, b) && intersects(a, p, p.next, b) && locally_inside(a, b) && locally_inside(b, a) {
			triangles = append(triangles, a.i/dim)
			triangles = append(triangles, p.i/dim)
			triangles = append(triangles, b.i/dim)
			// remove two nodes involved
			remove_node(p)
			remove_node(p.next)
			p = b
			start = b
		}
		p = p.next
		if p == start {
			break
		}
	}
	return filter_points(p, nil)
}

// split_earcut try splitting polygon into two and triangulate them independently
func split_earcut(start *Node, triangles []int, dim int, min_x float32, min_y float32, inv_size float32) {
	// look for a valid diagonal that divides the polygon into two
	a := start
	for {
		b := a.next.next
		for b != a.prev {
			if a.i != b.i && is_valid_diagonal(a, b) {
				// split the polygon in two by the diagonal
				c := split_polygon(a, b)
				// filter colinear points around the cuts
				a = filter_points(a, a.next)
				c = filter_points(c, c.next)
				// run earcut on each half
				earcut_linked(a, triangles, dim, min_x, min_y, inv_size, 0)
				earcut_linked(c, triangles, dim, min_x, min_y, inv_size, 0)
				return
			}
			b = b.next
		}
		a = a.next
		if a == start {
			break
		}
	}
}

// eliminate_holes link every hole into the outer loop, producing a single-ring polygon without holes
func eliminate_holes(data []float32, hole_indices []int, outer_node *Node, dim int) *Node {
	queue := []*Node{}
	length := len(hole_indices)
	start := 0
	end := 0
	list := &Node{}
	for i := 0; i < length; i++ {
		start = hole_indices[i] * dim
		if i < length-1 {
			end = hole_indices[i+1] * dim
		} else {
			end = len(data)
		}
		list = linked_list(data, start, end, dim, false)
		if list == list.next {
			list.steiner = true
		}
		queue = append(queue, get_leftmost(list))
	}
	//queue.sort(a.x - b.x) // TODO
	//queue.sort(fn(a *Node, b *Node) int { return a.x - b.x })
	// process holes from left to right
	list = nil
	for i := 0; i < len(queue); i++ {
		list = queue[i]
		eliminate_hole(list, outer_node)
		outer_node = filter_points(outer_node, outer_node.next)
	}
	return outer_node
}

/*function compareX(a, b) {
    return a.x - b.x;
}*/

// eliminate_hole find a bridge between vertices that connects hole with an outer ring and and link it
func eliminate_hole(hole *Node, outer_node *Node) {
	outer_node = find_hole_bridge(hole, outer_node)
	if !(outer_node == nil) {
		b := split_polygon(outer_node, hole)
		// filter collinear points around the cuts
		filter_points(outer_node, outer_node.next)
		filter_points(b, b.next)
	}
}

// find_hole_bridge David Eberly's algorithm for finding a bridge between hole and outer polygon
func find_hole_bridge(hole *Node, outer_node *Node) *Node {
	p := outer_node
	hx := hole.x
	hy := hole.y
	qx := float32(-math.MaxFloat32)
	m := &Node{}
	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	x := float32(0)
	for {
		if hy <= p.y && hy >= p.next.y && p.next.y != p.y {
			x = p.x + (hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y)
			if x <= hx && x > qx {
				qx = x
				if x == hx {
					if hy == p.y {
						return p
					}
					if hy == p.next.y {
						return p.next
					}
				}
				if p.x < p.next.x {
					m = p
				} else {
					m = p.next
				}
			}
		}
		p = p.next
		if p == outer_node {
			break
		} //while (p !== outerNode);
	}
	if m == nil {
		return m
	}
	if hx == qx {
		return m
	} // hole touches outer segment; pick leftmost endpoint
	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point
	stop := m
	mx := m.x
	my := m.y
	tan_min := float32(math.MaxFloat32)
	tan := float32(0)
	p = m
	for {
		var arg0 float32
		if hy < my {
			arg0 = float32(hx)
		} else {
			arg0 = float32(qx)
		}
		var arg4 float32
		if hy < my {
			arg4 = float32(qx)
		} else {
			arg4 = float32(hx)
		}
		if hx >= p.x && p.x >= mx && hx != p.x && point_in_triangle(
			arg0,
			hy, mx, my,
			arg4,
			hy, p.x, p.y) {
			tan = float32(float32(math.Abs(float64(hy-p.y))) / (hx - p.x)) // tangential
			if locally_inside(p, hole) &&
				(tan < tan_min || (tan == tan_min && (p.x > m.x || (p.x == m.x && sector_contains_sector(m, p))))) {
				m = p
				tan_min = tan
			}
		}
		p = p.next
		if p == stop {
			break
		} // while (p !== stop);
	}
	return m
}

// sector_contains_sector whether sector in vertex m contains sector in vertex p in the same coordinates
func sector_contains_sector(m *Node, p *Node) bool {
	return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0
}

// index_curve interlink polygon nodes in z-order
func index_curve(start *Node, min_x float32, min_y float32, inv_size float32) {
	p := start
	for {
		if p.z == 0 {
			p.z = z_order(p.x, p.y, min_x, min_y, inv_size)
		}
		p.prev_z = p.prev
		p.next_z = p.next
		p = p.next
		if p == start {
			break
		}
	}
	p.prev_z.next_z = nil
	p.prev_z = nil
	sort_linked(p)
}

// sort_linked Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
func sort_linked(list *Node) *Node {
	i := 0
	p := &Node{}
	q := &Node{}
	e := &Node{}
	tail := &Node{}
	num_merges := 0
	p_size := 0
	q_size := 0
	in_size := 1
	for {
		p = list
		list = nil //&Node{}
		tail = nil //&Node{}
		num_merges = 0
		for !(p == nil) {
			num_merges++
			q = p
			p_size = 0
			for i = 0; i < in_size; i++ {
				p_size++
				q = q.next_z
				if q == nil {
					break
				}
			}
			q_size = in_size
			for p_size > 0 || (q_size > 0 && !(q == nil)) {
				if p_size != 0 && (q_size == 0 || (q == nil) || p.z <= q.z) {
					e = p
					p = p.next_z
					p_size--
				} else {
					e = q
					q = q.next_z
					q_size--
				}
				if !(tail == nil) {
					tail.next_z = e
				} else {
					list = e
				}
				e.prev_z = tail
				tail = e
			}
			p = q
		}
		tail.next_z = nil //&Node{}
		in_size *= 2
		if num_merges > 1 {
			break
		}
	}
	return list
}

// z_order z-order of a point given coords and inverse of the longer side of data bbox
func z_order(x float32, y float32, min_x float32, min_y float32, inv_size float32) float32 {
	// coords are transformed into non-negative 15-bit integer range
	nx := 32767 * uint32(uint16(x-min_x)*uint16(inv_size))
	ny := 32767 * uint32(uint16(y-min_y)*uint16(inv_size))

	nx = (nx | (nx << 8)) & 0x00FF00FF
	nx = (nx | (nx << 4)) & 0x0F0F0F0F
	nx = (nx | (nx << 2)) & 0x33333333
	nx = (nx | (nx << 1)) & 0x55555555

	ny = (ny | (ny << 8)) & 0x00FF00FF
	ny = (ny | (ny << 4)) & 0x0F0F0F0F
	ny = (ny | (ny << 2)) & 0x33333333
	ny = (ny | (ny << 1)) & 0x55555555

	return float32(nx | (ny << 1))
}

// get_leftmost find the leftmost node of a polygon ring
func get_leftmost(start *Node) *Node {
	p := start
	leftmost := start
	for {
		if p.x < leftmost.x || (p.x == leftmost.x && p.y < leftmost.y) {
			leftmost = p
		}
		p = p.next
		if p == start {
			break
		}
	}
	return leftmost
}

// point_in_triangle check if a point lies within a convex triangle
func point_in_triangle(ax float32, ay float32, bx float32, by float32, cx float32, cy float32, px float32, py float32) bool {
	return (cx-px)*(ay-py)-(ax-px)*(cy-py) >= 0 &&
		(ax-px)*(by-py)-(bx-px)*(ay-py) >= 0 &&
		(bx-px)*(cy-py)-(cx-px)*(by-py) >= 0
}

// is_valid_diagonal check if a diagonal between two polygon nodes is valid (lies in polygon interior)
func is_valid_diagonal(a *Node, b *Node) bool {
	doesnt_intersect := a.next.i != b.i && a.prev.i != b.i && !intersects_polygon(a, b)            // dones't intersect other edges
	locally_visible := locally_inside(a, b) && locally_inside(b, a) && middle_inside(a, b)         // locally visible
	not_opposite_facing := (area(a.prev, a, b.prev) != 0.0 || area(a, b.prev, b) != 0.0)           // does not create opposite-facing sectors
	zero_length_case := equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0 // special zero-length case
	return doesnt_intersect && ((locally_visible && not_opposite_facing) || zero_length_case)
}

// area signed area of a triangle
func area(p *Node, q *Node, r *Node) float32 {
	return (q.y-p.y)*(r.x-q.x) - (q.x-p.x)*(r.y-q.y)
}

// equals check if two points are equal
func equals(p1 *Node, p2 *Node) bool {
	return p1.x == p2.x && p1.y == p2.y
}

// intersects check if two segments intersect
func intersects(p1 *Node, q1 *Node, p2 *Node, q2 *Node) bool {
	o1 := sign(area(p1, q1, p2))
	o2 := sign(area(p1, q1, q2))
	o3 := sign(area(p2, q2, p1))
	o4 := sign(area(p2, q2, q1))
	if o1 != o2 && o3 != o4 {
		return true
	} // general case
	if o1 == 0 && on_segment(p1, p2, q1) {
		return true
	} // p1, q1 and p2 are collinear and p2 lies on p1q1
	if o2 == 0 && on_segment(p1, q2, q1) {
		return true
	} // p1, q1 and q2 are collinear and q2 lies on p1q1
	if o3 == 0 && on_segment(p2, p1, q2) {
		return true
	} // p2, q2 and p1 are collinear and p1 lies on p2q2
	if o4 == 0 && on_segment(p2, q1, q2) {
		return true
	} // p2, q2 and q1 are collinear and q1 lies on p2q2
	return false
}

// on_segment for collinear points p, q, r, check if point q lies on segment pr
func on_segment(p *Node, q *Node, r *Node) bool {
	return q.x <= max_float32(p.x, r.x) && q.x >= min_float32(p.x, r.x) && q.y <= max_float32(p.y, r.y) && q.y >= min_float32(p.y, r.y)
}

func max_float32(a float32, b float32) float32 {
	if a > b {
		return a
	}
	return b
}

func min_float32(a float32, b float32) float32 {
	if a < b {
		return a
	}
	return b
}

func sign(num float32) int {
	if num > 0 {
		return 1
	} else if num < 0 {
		return -1
	}
	return 0
}

// intersects_polygon check if a polygon diagonal intersects any polygon segments
func intersects_polygon(a *Node, b *Node) bool {
	//p := &Node{}
	p := a
	for {
		if p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i && intersects(p, p.next, a, b) {
			return true
		}
		p = p.next
		if p == a {
			break
		}
	}
	return false
}

// locally_inside check if a polygon diagonal is locally inside the polygon
func locally_inside(a *Node, b *Node) bool {
	if area(a.prev, a, a.next) < 0 {
		return area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0
	} else {
		return area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
	}
}

// middle_inside check if the middle point of a polygon diagonal is inside the polygon
func middle_inside(a *Node, b *Node) bool {
	p := a
	//p := &Node{}
	inside := false
	px := (a.x + b.x) / 2
	py := (a.y + b.y) / 2

	for {
		if ((p.y > py) != (p.next.y > py)) && p.next.y != p.y && (px < (p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x) {
			inside = !inside
		}
		p = p.next
		if p == a {
			break
		}
	}
	return inside
}

// split_polygon link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
func split_polygon(a *Node, b *Node) *Node {
	a2 := &Node{
		i: a.i,
		x: a.x,
		y: a.y,
	}
	b2 := &Node{
		i: b.i,
		x: b.x,
		y: b.y,
	}
	an := a.next
	bp := b.prev
	a.next = b
	b.prev = a
	//
	a2.next = an
	an.prev = a2
	//
	b2.next = a2
	a2.prev = b2
	//
	bp.next = b2
	b2.prev = bp
	return b2
}

// insert_node create a node and optionally link it with previous one (in a circular doubly linked list)
func insert_node(i int, x float32, y float32, last *Node) *Node {
	p := &Node{
		i: i,
		x: x,
		y: y,
	}
	if last == nil {
		p.prev = p
		p.next = p
	} else {
		p.next = last.next
		p.prev = last
		last.next.prev = p
		last.next = p
	}
	return p
}

func remove_node(p *Node) {
	p.next.prev = p.prev
	p.prev.next = p.next
	if !(p.prev_z == nil) {
		p.prev_z.next_z = p.next_z
	}
	if !(p.next_z == nil) {
		p.next_z.prev_z = p.prev_z
	}
	//TODO unsafe { free(p) }
}

type Node struct {
	// vertex index in coordinates array
	i int
	// vertex coordinates
	x float32
	y float32
	// previous and next vertex nodes in a polygon ring
	prev *Node
	next *Node
	// z-order curve value
	z float32
	// previous and next nodes in z-order
	prev_z *Node
	next_z *Node
	// indicates whether this is a steiner point
	steiner bool
}

// deviation return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
func Deviation(data []float32, hole_indices []int, dim int, triangles []int) float32 {
	has_holes := len(hole_indices) > 0
	var outer_len int
	if has_holes {
		outer_len = hole_indices[0] * dim
	} else {
		outer_len = len(data)
	}
	polygon_area := float32(math.Abs(float64(signed_area(data, 0, outer_len, dim))))
	if has_holes {
		i := 0
		length := len(hole_indices)
		start := hole_indices[0] * dim
		var end int
		if i < length-1 {
			end = hole_indices[i+1] * dim
		} else {
			end = len(data)
		}
		for ; i < length; i++ {
			start = hole_indices[i] * dim
			if i < length-1 {
				end = hole_indices[i+1] * dim
			} else {
				end = len(data)
			}
			polygon_area -= float32(math.Abs(float64(signed_area(data, start, end, dim))))
		}
	}
	triangles_area := float32(0)
	for i := 0; i < len(triangles); i += 3 {
		a := int(triangles[i] * dim)
		b := int(triangles[i+1] * dim)
		c := int(triangles[i+2] * dim)
		triangles_area += float32(math.Abs(float64(
			(data[a]-data[c])*(data[b+1]-data[a+1]) -
				(data[a]-data[b])*(data[c+1]-data[a+1]))))
	}
	if polygon_area == 0 && triangles_area == 0 {
		return 0
	} else {
		return float32(math.Abs(float64((triangles_area - polygon_area) / polygon_area)))
	}
}

func signed_area(data []float32, start int, end int, dim int) float32 {
	sum := float32(0)
	j := end - dim
	i := start
	for ; i < end; i += dim {
		sum += (data[j] - data[i]) * (data[i+1] + data[j+1])
		j = i
	}
	return sum
}

type FlatResult struct {
	dimensions int
	vertices   []float32
	holes      []int
}

// flatten turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
func Flatten(data [][][]float32) FlatResult {
	dim := len(data[0][0])
	result := FlatResult{dimensions: dim}
	hole_index := 0
	for i := 0; i < len(data); i++ {
		for j := 0; j < len(data[i]); j++ {
			for d := 0; d < dim; d++ {
				result.vertices = append(result.vertices, data[i][j][d])
			}
		}
		if i > 0 {
			hole_index += len(data[i-1])
			result.holes = append(result.holes, hole_index)
		}
	}
	return result
}
